package net.verdagon.vale.scout.rules

import net.verdagon.vale.scout._
import net.verdagon.vale.solver._
import net.verdagon.vale.{vfail, vimpl}

import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer

object RuleFlattener {
//  // Returns:
//  // - Map of scout rune to rune index
//  // - The initially known types of some runes
//  // - For each rune, whether it's predictable, in other words ordinary, not involving generics
//  // - Num canonical runes
//  // - The canonical rules, in the order they should be executed in
//  def flattenAndCompileRules(
//    runeSToTentativeRune: mutable.HashMap[IRuneS, TentativeRune],
//    runeToCanonicalRune: Map[TentativeRune, Int],
//    tentativeRuneToType: mutable.HashMap[TentativeRune, ITypeSR],
//    world: World[Int, RangeS, ILiteralSR, ILookupSR]):
////    knowableRunesFromAbove: Set[IRuneS],
////    rulesS: Vector[IRulexSR]):
//  (Map[IRuneS, Int], Map[IRuneS, ITypeSR], Map[IRuneS, Boolean], Int, Array[IRulexAR[Int, RangeS, ILiteralSR, ILookupSR]]) = {
//
//
//  }

//  def flattenAndOptimizeRules(knowableRunesFromAbove: Set[IRuneS], rulesS: Vector[IRulexSR]):
//  (
//    mutable.HashMap[IRuneS, TentativeRune],
//      Map[TentativeRune, Int],
//      mutable.HashMap[TentativeRune, ITypeSR],
//      World[Int, RangeS, ILiteralSR, ILookupSR]) = {
//  }

}
